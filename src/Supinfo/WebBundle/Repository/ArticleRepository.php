<?php

namespace Supinfo\WebBundle\Repository;

use Doctrine\ORM\QueryBuilder;

use Supinfo\WebBundle\Entity\Article;

/**
 * ArticleRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ArticleRepository extends EntityRepository
{

    public function checkArticleFieldValues(\Supinfo\WebBundle\Entity\Article $article)
    {
        // Add missing fieldValues
        foreach ($article->getSubFamily()->getFields() as $field) {
            foreach ($article->getFieldValues() as $fieldValue) {
                if ($fieldValue->getSubFamilyField() == $field) {
                    break 2;
                }
            }

            $options = array(
                'subFamilyField' => $field,
                'article' => $article,
            );
            $newFieldValue = new \Supinfo\WebBundle\Entity\SubFamilyFieldValue($options);

            $article->getFieldValues()->add($newFieldValue);
        }

        // We have to remove the field values corresponding to the wrong subFamily.
        foreach ($article->getFieldValues() as $fieldValue) {
            if ($fieldValue->getSubFamilyField()->getSubFamily() != $article->getSubFamily()) {
                $article->getFieldValues()->removeElement($fieldValue);
                $this->getEntityManager()->remove($fieldValue);
            }
        }
    }

    public function selectByIdQB($id)
    {
        $qb = parent::selectByIdQB($id);

        $qb->addSelect(
            'sf'
        )->innerJoin(
            $qb->getRootAlias().'.subFamily',
            'sf'
        );

        $qb->addSelect(
            'sff'
        )->leftJoin(
            'sf.fields',
            'sff'
        );

        $qb->addSelect(
            'fv'
        )->leftJoin(
            $qb->getRootAlias().'.fieldValues',
            'fv'
        );

        return $qb;
    }

    public function searchQB($query)
    {
        $qb = parent::searchQB($query);

        $qb->setParameter('query_like', '%'.$query.'%');
        $qb->setParameter('query_id', preg_match('/^1[0-9]{4}$/', $query) ? substr($query, 1) : $query);

        return $qb;
    }

    public function getSearchExpr(QueryBuilder $qb)
    {
        $expr = parent::getSearchExpr($qb);

        $expr->add(
            $qb->expr()->like(
                $qb->getRootAlias().'.description',
                ':query_like'
            )
        );
        
        $expr->add(
            $qb->expr()->eq(
                $qb->getRootAlias().'.id',
                ':query_id'
            )
        );

        return $expr;
    }


    /**
     * Returns an array containing loan aware quantities for each date the quantity changes.
     */
    public function getAvailability(Article $article)
    {
        $articleLoans = $article->getArticleLoans();

        $results = array();
        $results[1] = $article->getQuantity();

        foreach ($articleLoans as $articleLoan) {
            $dateStart = $articleLoan->getDateStart()->getTimestamp();
            $dateEnd = $articleLoan->getDateEnd()->getTimestamp();

            // Create start in array
            if (isset($results[$dateStart])) {
                $results[$dateStart] -= $articleLoan->getQuantity();
            } else {
                // Get the previous quantity.

                $results[$dateStart] = $this->getPreviousTimestampQuantity($results, $dateStart) - $articleLoan->getQuantity();
            }

            $dateStartPreviousQuantity = $results[$dateStart] + $articleLoan->getQuantity();


            // Adjust each value between start and end
            foreach ($results as $resultTimeStamp => $quantity) {
                if ($resultTimeStamp > $dateStart && $resultTimeStamp < $dateEnd) {
                    $results[$resultTimeStamp] -= $articleLoan->getQuantity();
                }
            }


            // Create end in array if necessary
            if (!isset($results[$dateEnd])) {
                $results[$dateEnd] = $dateStartPreviousQuantity;
            }
        }

        // Creating result array with DateTime instances.
        ksort($results);
        $resultsDateTime = array();
        foreach ($results as $resultTimeStamp => $quantity) {
            $dt = new \DateTime();
            $dt->setTimestamp($resultTimeStamp);

            $resultsDateTime[] = array(
                'quantity' => $quantity,
                'date' => $dt
            );
        }

        return $resultsDateTime;
    }

    private function getPreviousTimestampQuantity($results, $timestamp) {
        $previousTimestamp = null;
        $previousDiff = null;
        foreach ($results as $resultTimestamp => $quantity) {
            $diff = $timestamp - $resultTimestamp;
            if ($previousDiff === null || ($diff > 0 && $diff < $previousDiff)) {
                $previousDiff = $diff;
                $previousTimestamp = $resultTimestamp;
            }
        }

        return $results[$previousTimestamp];
    }

}